### Complie 과정을 말해라
1. 개발자가 .java 파일을 생성한다.
2. build를 한다.
3. java compiler의 javac의 명령어를 통해서 바이트코드(.class)를 생성한다.
4. class loader를 통해 JVM으로 로드한다.
5. 실행엔진을 통해서 컴퓨터가 읽을 수 있는 기계어로 해석되어(각 운영체제에 맞는 기계어) Runtime Data Area에 배치된다.


### Compiler vs Interpreter 의 차이점

Compiler는 고수준 언어로 작성된 코드를 기계어로 변환하는 도구입니다. Compiler는 소스 코드 전체를 변환하여 실행 가능한 프로그램을 생성합니다. 이렇게 생성된 프로그램은 기계어로 변환되어 있으므로, 실행할 때 추가적인 변환 과정 없이 직접 실행됩니다. 이는 실행 시간에 빠른 성능을 제공하는 이점을 가지고 있습니다.

반면에 Interpreter는 소스 코드를 한 줄씩 읽고 해석하여 실행하는 방식을 취합니다. Interpreter는 소스 코드를 직접 변환하지 않고, 실행 시에 한 줄씩 해석하여 결과를 확인합니다. 이는 프로그램의 수정이 용이하고, 개발 과정에서 보다 빠른 피드백을 제공하는 이점을 가지고 있습니다. 하지만 매번 실행할 때마다 해석 과정을 거치므로 실행 시간이 상대적으로 느릴 수 있습니다.

따라서, 일반적으로 Compiler로 생성된 프로그램은 Interpreter를 통해 실행하는 것보다 실행 속도가 빠릅니다. 그러나 Interpreter는 실행 시간에 코드를 직접 해석하므로 수정과 디버깅이 편리하며, 개발 과정에서 유용합니다.

### String, StringBuilder, StringBuffer의 차이
**String**
- String 객체는 불변 객체이기 때문에 변하지 않는 문자열을 자주 읽어들이는 경우 String을 사용합니다.
- String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성됩니다.
- 문자열 추가, 수정, 삭제 등이 빈번하게 발생하는 경우 String 클래스를 사용하면 **힙 메모리(Heap)에 많은 임시 가비지(Garbage)가 생성**되어 힙메모리 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다.

**StringBuffer / StringBuilder**
- String 과는 반대로 StringBuffer/StringBuilder 는 가변성 가지기 때문에 동일 객체내에서 문자열을 변경하는 것이 가능합니다.
- StringBuffer와 StringBuilder는 동기화 유무의 차이가 있습니다.
- StringBuffer의 경우 동기화를 지원해서 멀티쓰레드 환경에서 안전(thread-safe)합니다.
- StringBuilder는 동기화를 지원하지 않아서 멀티쓰레드 환경에서 사용하는 것은 적합하지 않습니다. 그래도 단일쓰레드 환경에서는 StringBuffer보다 성능이 뛰어납니다.


### OOP의 4가지 특징

1. **추상화**
	공통의 속성이나 기능을 묶어 이름을 붙이는 것을 추상화라고 할 수 있다.
	- 객체 지향적 관점에서 클래스를 정의하는 것을 추상화라고 할 수 있다. 예를 들어 사자, 고양이, 강아지가 있을 때 우리는 이것을 각각 객체라고 하며, 이 객체들의 공통점인 동물이라고 표현할 수 있는데 이 때, 동물로 묶는 행위를 추상화라고 한다.
2. **캡슐화**
	특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.
	
	은닉화 vs 캡슐화
	- 정보 은닉의 한 종류가 캡슐화이다.
	- 객체의 구체적인 타입 은닉 ( = 업캐스팅)
		- 자식 객체의 타입을 부모 객체의 타입으로 형변환 하는 UpCasting도 일종의 정보 은닉
	- 객체의 필드 및 메소드 은닉 ( = 캡슐화)
	- 구현 은닉 ( = 인터페이스 & 추상 클래스)
1. **상속성**
	자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것이다.
4. **다형성**
	같은 메서드 이름으로 다른 동작을 하는 것. 자식에서 재정의를 하는 것.